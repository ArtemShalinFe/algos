/*
https://contest.yandex.ru/contest/25597/run-report/116887772/

### Принцип работы

	Программа использует модифициированный алгоритм Вагнера-Фишера для рассчета расстояния Левенштейна у предложенной
	пары строк. Модификация заключается в том, что программа не хранит в памяти всю матрицу, а сохраняет и обновляет
	расстояние редактирования в одной строке.

### Доказательство корректности

	Объявляем буфер для сохранения расстояния редактирования предыдущей строки равный размеру строки s и заполняем его
	от 1 до n, где n - длина строки s.

	Объявляем временную переменную tmp, в которой будет хранится значение слева сверху относительно текущей рассчитываемой ячейки.
	По умолчанию считаем, что нужно будет заменить все символы в строке t, поэтому присваиваем ей порядковый номер текущего символа.

	на каждой итерации цикла строки t по строке s программа сравниваеи каждый символ строки s с каждым символом строки t.
	Если символы не равны, то программа берет минимум от значений:
	- Слева от текущей ячейки
	- Сверху от текущей ячейки
	- Сверху слева от текущей ячейки

	Добавляет к этому значению единицу и это значение ставит как новое "значение сверху".

	Если символы равны, то обновляется временная переменная tmp значением "значение сверху".

	После цикла строки t по строке s по таким правилам, рассчитанное расстояние редактирования будет в последней ячейке буфера.

### Временная сложность

	Программа для рассчета расстояния сравнивает каждый символ строки S с каждым символом строки T.
	Заполняет буфер равный размеру строки S.

	Временная сложность: О(S*T)

### Пространственная сложность

	В памяти программы единовременно хранится:
	- Массив символов S равный размеру строки s,
	- Массив символов T равный размеру строки t,
	- Буфер для рассчета расстояния редактирования между символами равный размеру строки s.

	Пространственная сложность: О(S+T)
*/
package main

import (
	"bufio"
	"os"
	"strconv"
	"strings"
)

func solution(s []string, t []string) int {
	buf := make([]int, len(s)+1)
	for i := 1; i < len(buf); i++ {
		buf[i] = i
	}

	for i := 1; i <= len(t); i++ {
		tmp := i

		for j := 1; j <= len(s); j++ {
			if t[i-1] != s[j-1] {
				val := min(
					buf[j],   // слева
					buf[j-1], // сверху
					tmp,      // слева сверху
				) + 1

				buf[j-1], tmp = tmp, val
			} else {
				buf[j-1], tmp = tmp, buf[j-1]
			}
		}

		buf[len(s)] = tmp
	}

	return buf[len(s)]
}

func main() {
	scanner := makeScanner()
	firstWord := readArray(scanner)
	secondpWord := readArray(scanner)
	print(solution(firstWord, secondpWord))
}

func readArray(scanner *bufio.Scanner) []string {
	scanner.Scan()
	return strings.Split(scanner.Text(), "")
}

func makeScanner() *bufio.Scanner {
	const maxCapacity = 3 * 1024 * 1024
	tmp := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(tmp, maxCapacity)
	return scanner
}

func print(ans int) {
	writer := bufio.NewWriter(os.Stdout)
	writer.WriteString(strconv.Itoa(ans))
	writer.Flush()
}
