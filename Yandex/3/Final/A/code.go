/*
https://contest.yandex.ru/contest/23815/run-report/115025219/

### Принцип работы

	В начале каждой итерации цикла находим средний элемент сверяем с искомым.
	Основная идея алгоритма заключается в том, чтобы, перед тем как разделять массив на текущей итерации цикла,
	убедиться, что массив, который получился в результате деления на 2, отсортирован правильно.
	То есть крайний левый элемент текущего диапазона меньше элемента в середине, если это не так, то программа
	должна выполнять поиск в другой части.
	После того, как программа проверила, что диапазон отсортирован корректно нужно проверить, что искомое число К находится
	в диапазоне поиска
	Таким образом,
	- если К в левой части массива, то сдвигаем правую границу на середину,
	- если К не в левой части массива, то сдвигаем левую границу на середину,
	- если К в правой части, то сдвигаем левую границу на середину,
	- если К не в правой части, то сдвигаем правую границу на середину.

	Так как программа в начале каждой итерации проверяет значение в среднем элементе, можно увеличивать или
	уменьшать индекс среднего элемента при смещении границы в завиимости от направления смещения.

### Доказательство корректности

	Алгоритм является вариацией алгоритма бинарного поиска. Отличие состоит в том, что текущий алгоритм
	проверяет корректно отсортирован массив или нет и корректирует диапазон поиска.

### Временная сложность

	При каждой итерации общая длина массива уменьшается на 2, таким образом получается, что:
	- Временная сложность - O(logn)

### Пространственная сложность

	В памяти  программы хранится только массив, который был передан во входных данных, таким образом получается, что:
	- Пространственная сложность - O(n)
*/
package main

func brokenSearch(arr []int, k int) int {
	left := 0
	right := len(arr) - 1

	for left <= right {
		mid := (left + right) / 2

		if arr[mid] == k {
			return mid
		}

		if arr[left] > arr[mid] {
			if k <= arr[right] && k > arr[mid] {
				left = mid + 1
			} else {
				right = mid - 1
			}
		} else {
			if k >= arr[left] && k < arr[mid] {
				right = mid - 1
			} else {
				left = mid + 1
			}
		}
	}

	return -1
}
